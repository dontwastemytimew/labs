# Перелік 1: структури даних та алгоритми.

#### 7. (****) Графи на основі списку суміжності, матриці суміжності (збереження даних у вершинах та ребрах графів). Додавання та видалення вершин/ребер. Перевірка на зв’язність графу. Визначення відстані між двома вершинами графу.

* Базовий клас: Graph<vertexT, edgeT>
* Підкласи: AdjacencyListGraph<vertexT, edgeT>, AdjacencyMatrixGraph<vertexT, edgeT>

* Збереження даних: struct Data { vertexT vertexData; edgeT edgeData; int number; }

Основні операції:

* Додавання/видалення вершин: addVertex(), removeVertex()

* Додавання/видалення ребер: addEdge(), removeEdge()

* Перевірка на зв’язність: isConnected()

* Визначення відстані між вершинами: distance()

#### a. +* За інші алгоритми на графах

* Алгоритм Дейкстри для знаходження відстані між двома вершинами (distance())
* Алгоритм Прима для побудови мінімального кістякового дерева зваженого зв'язного неорієнтованого графу (primMST())
# Перелік 2: класи для опису даних.

##### 5. Транспортні засоби.

* a. 

**Транспортні засоби різних типів – наземні, водні, повітряні:**
 
Реалізовано через класи LandVehicle, WaterVehicle, AirVehicle, що наслідують BaseVehicle. Кожен об’єкт зберігає назву, тип транспортного засобу та швидкість (speed), яка використовується для обчислення ефективної “ваги” руху на графі. 

**Середовище, яким вони пересуваються (пункти відправлення/призначення, дороги, перешкоди):**

Реалізовано класом шаблону Environment<GraphType, VertexT>, який поєднує граф (список або матрицю суміжності) з транспортними засобами. Пункти представлені вершинами графу (VertexT), дороги – ребрами з вагою (відстань) та типом (VehicleType). Типи дороги зберігаються у map<pair<VertexT, VertexT>, VehicleType> для перевірки, чи транспортний засіб може рухатися по цій дорозі.

* b.

**Обчислення оптимальних шляхів між заданими пунктами для транспортних засобів:**

Реалізовано у методі computeOptimalRoute(vehicleIndex, from, to) через алгоритм Дейкстри, який враховує вагу ребер і тип дороги (AirVehicle може рухатися по будь-яких дорогах).

**Моделювання руху транспортних засобів:**

Реалізовано методами moveVehicle(vehicleIndex, destination) та simulateRoute(vehicleIndex, route). Виконується переміщення транспортного засобу по маршруту з перевіркою можливості руху, обчисленням ефективної відстані та оновленням поточної позиції.

* c.

**Інтеграція з існуючими засобами моделювання, та/або видобування інформації про реальні транспортні засоби та середовище.**

Реалізовано зчитуванням/записом у файл.


### Вимоги:
* Класи: 9 — вимога виконана

* Поля: 15 — вимога виконана

* Нетривіальні методи: >25 — вимога виконана

* Ієрархії успадкування: 2 (одна з ≥3 класів) — вимога виконана

* Випадки поліморфізму: 3 (є статичний і динамічний) — вимога виконана

* Інкапсуляція: присутня — вимога виконана

Реалізовані структури даних підтримують роботу з даними різних типів. 
Продемонстрована робота системи на примітивних типах (int, double), бібліотечних типах (string, vector), а також реалізованих класах (Перелік 2).
Для всіх структур даних реалізувано методи отримання текстового подання (наприклад, з метою виводу на екран), а також генерації відповідних структур даних, заповнених випадковими даними.

#### Використано юніт-тестування.
#### Використано засоби документування коду, які генерують документацію з коментарів (Doxygen).
